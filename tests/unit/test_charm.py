# Copyright 2023 Canonical Ltd.
# See LICENSE file for licensing details.

"""Flask charm unit tests."""

# pylint: disable=protected-access

import textwrap
import unittest.mock

import pytest
from ops.testing import Harness

from charm import FlaskCharm
from charm_state import CharmState
from webserver import GunicornWebserver

FLASK_BASE_DIR = "/srv/flask"


@pytest.mark.usefixtures("mock_container_fs", "mock_container_exec")
def test_flask_pebble_layer(harness: Harness) -> None:
    """
    arrange: none
    act: start the flask charm and set flask-app container to be ready.
    assert: flask charm should submit the correct flaks pebble layer to pebble.
    """
    harness.begin_with_initial_hooks()
    harness.set_can_connect(harness.model.unit.containers["flask-app"], True)
    harness.framework.reemit()
    flask_layer = harness.get_container_pebble_plan("flask-app").to_dict()["services"]["flask-app"]
    assert flask_layer == {
        "override": "replace",
        "summary": "Flask application service",
        "command": f"python3 -m gunicorn -c {FLASK_BASE_DIR}/gunicorn.conf.py app:app",
        "startup": "enabled",
        "user": "flask",
        "group": "flask",
    }


@pytest.mark.usefixtures("mock_container_exec")
@pytest.mark.parametrize(
    "charm_state_params, config_file",
    [
        (
            {"webserver_workers": 10},
            textwrap.dedent(
                f"""\
                bind = ['0.0.0.0:8000']
                chdir = '{FLASK_BASE_DIR}/app'
                workers = 10"""
            ),
        ),
        (
            {"webserver_threads": 2, "webserver_timeout": 3, "webserver_keepalive": 4},
            textwrap.dedent(
                f"""\
                bind = ['0.0.0.0:8000']
                chdir = '{FLASK_BASE_DIR}/app'
                threads = 2
                keepalive = 4
                timeout = 3"""
            ),
        ),
    ],
)
def test_gunicorn_config(
    monkeypatch,
    harness: Harness,
    mock_container_fs: dict[str, str],
    charm_state_params,
    config_file,
) -> None:
    """
    arrange: start the flask charm and set flask-app container to be ready with a controlled charm
        state generated by the charm_state_params parameter.
    act: run the callback function of the config-changed event.
    assert: gunicorn configuration file inside the flask app container should change accordingly.
    """
    harness.begin_with_initial_hooks()
    harness.set_can_connect(harness.model.unit.containers["flask-app"], True)
    monkeypatch.setattr(
        harness.charm, "_webserver", GunicornWebserver(CharmState(**charm_state_params))
    )
    harness.charm._on_config_changed(unittest.mock.MagicMock())
    assert mock_container_fs.get(f"{FLASK_BASE_DIR}/gunicorn.conf.py") == config_file


@pytest.mark.usefixtures("mock_container_fs", "mock_container_exec")
def test_webserver_reload(
    monkeypatch,
    harness: Harness,
):
    """
    arrange: start the flask charm and start the flask service by invoking the config-changed
        callback.
    act: invoke the callback function of the config-changed event with a different charm state.
    assert: charm should send a reload signal to the webserver to reload the configuration.
    """
    mock_reload_webserver = unittest.mock.MagicMock()
    monkeypatch.setattr(FlaskCharm, "reload_webserver", mock_reload_webserver)
    harness.begin_with_initial_hooks()
    harness.set_can_connect(harness.model.unit.containers["flask-app"], True)
    harness.charm._on_config_changed(unittest.mock.MagicMock())

    assert not mock_reload_webserver.called

    monkeypatch.setattr(
        harness.charm, "_webserver", GunicornWebserver(CharmState(webserver_workers=100))
    )
    harness.charm._on_config_changed(unittest.mock.MagicMock())
    harness.charm._on_config_changed(unittest.mock.MagicMock())

    assert mock_reload_webserver.call_count == 1
